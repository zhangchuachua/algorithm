// *2022-5-25 每日一题 动态规划

// *https://leetcode.cn/problems/unique-substrings-in-wraparound-string/ leetcode-467
// *开始做了一版暴力解法，通过不了测试。 这道题其实运用了 滑动窗口和动态规划 两种思路
/**
 * !这道题求 字符串 p 在无限循环字符串 s 中的所有**非空**子串的数量。那么我们看向 p 字符串，假设当前的 p 字符串是 'zabx' 要求在 s 中的非空子串的数量，那我们就要先找到子串。注意，在找子串的时候，应该找最长子串，因为最长子串已经包含内部其他子串了。
 *
 * !很明显，zab, x 就是存在与 s 中的子串，然后我们把它们对应的数量求出来就可以了， zab = ['z', 'a', 'b', 'za', 'ab', 'zab'] x = ['x'] 所以可以得出结果为 7。
 *
 * !x = ['x'] 很容易可以知道，重点就是如何确定 多字母字符串(例如 'zab')的子串数量呢？
 * 这是一个规律:
 * !z = ['z'] length = 1
 * !za = ['z', 'a', 'za'] = [...z, 'a', 'za'] length = 1 + 2 = 3
 * !zab = ['z', 'a', 'za', 'b', 'ab', 'zab'] = [...za, 'b', 'ab', 'zab'] length = 1 + 2 + 3 = 6
 * !当前 **字符串的子串的数量** 就是 **上一个字符串的子串 + 当前字符串的长度** 简单点说，就是一个等差数列 1 + 2 + ... + length
 * !为什么是 当前字符串的长度 呢？因为新增了一个字符，前面的字符串的子串已经列举完成了，新增的子串就是保留这个新字符，不断缩减字符串的长度(例如：['b', 'ab', 'zab']) 所以就是当前字符串的长度了
 */

// *这是 leetcode 官方的题解 思路太巧妙了
/**
 * 解题思路就是使用 count 来记录当前子串个数
 *
 * 然后遍历 p 字符串，将当前字符与前一个字符进行判断，判断是否为连续的字符，连续的字符才能形成子串，因为当前 s 是 'abc...xyz' 的无限循环。
 *
 * 如果不是连续的，那么当前字符子串个数只能是自己，也就是 count = 1。
 *
 * 如果是连续的，那么当前字符串子串个数就应该是 前一个字符串子串的个数 + 当前字符串的长度。因为要记录长度，所以就需要遇到连续字符就让 count += 1。
 *
 * 最后累加所有的 子串数 就可以了
 */
export function findSubstringInWraproundString(p: string): number {
  // *创建一个长度为 26 的数组，代表 26 个字母
  // *比如 [1, 2, 3, 0, ..., 0] 代表的就是 'abc' 的子串数
  const dp = new Array(26).fill(0);
  let count = 1;
  // *循环 p 字符串
  for (let i = 0; i < p.length; i++) {
    // *当前字符对应的 索引值 'a'.charCodeAt(0) = 97
    const index = p[i].charCodeAt(0) - 97;
    // *当前字符 code - 上一个字符 code === -25 | 1 时 代表连续
    if (i && (p[i].charCodeAt(0) - p[i - 1].charCodeAt(0) + 26) % 26 === 1) {
      // !如果是连续的，那么让 count += 1
      count += 1;
    } else {
      // 如果不连续 就让count = 1
      count = 1;
    }
    // *因为需要不重复的子串，所以这里只取 最大值
    dp[index] = Math.max(count, dp[index]);
  }
  // *累加所有的子串数
  return dp.reduce((a, b) => a + b);
}