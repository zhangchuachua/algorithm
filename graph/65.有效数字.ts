import { Graph } from "./base";

// *这是我一开始的思路，理清那些值后面可以接那些值，并且使用邻接表的方式列出来，然后循环字符串，比较当前字符和下一个字符是否符合规则，如果不符合规则就返回false，但是我这里对于特殊情况很难做，比如 'e' 'e9' 这样总是判断为true
// !这是错误的
// const graph: Graph = {
//   '0': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E'],
//   '1': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E'],
//   '2': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E'],
//   '3': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E'],
//   '4': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E'],
//   '5': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E'],
//   '6': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E'],
//   '7': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E'],
//   '8': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E'],
//   '9': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E'],
//   '.': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
//   '+': ['.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
//   '-': ['.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
//   'e': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-'],
//   'E': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
// };
//
// function isNumber(s: string): boolean {
//   for (let i = 0; i < s.length - 1; i++) {
//     const current = s[i];
//     const next = s[i + 1];
//     const allowCurrent = graph[current];
//     if(!allowCurrent || !allowCurrent.includes(next)) return false
//   }
//   return true;
// };

// !解体思路需要使用看看 算法.md 里面对应的一节
function isNumber(s:string):boolean {

}
