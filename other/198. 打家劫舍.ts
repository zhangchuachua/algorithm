// !动态规划题， 题目难度 medium
// !还是跟着三步骤走，一开始没有想出来，还是不够熟练，还需要继续练习。

// *1. 确定数组是一维数组还是二维，并且确定元素代表的含义。
// *2. 确定元素之间的关系，也就是推导关系式
// *3. 建立初始值。
// !1. 具体确定一维数组还是二维数组的方法我也不是很清楚，但是这道题好像不是很好建立二维数组，而且使用一个一维数组就可以解决问题，所以这里选择一维数组（遇到不知道多少维，就先根据直觉建立，或者一维二维先大致试一下，实在不行就只有看解析了） 每个元素自然代表的是当前能偷取到的最高金额。
// !2. 元素之间的关系： 要得出当前索引的最高金额，那么就要知道之前的最高金额是多少，然后加上当前索引的对应的金额就可以了。 也就是 dp[i]=max(dp[0]~dp[i-1]) + nums[i]; 当然这是错误了，因为题目中告诉了，不能偷取两间相邻的房间，所以式子应该为： dp[i] = max(dp[0]~dp[i-2]) + nums[i];
// !3. 初始值：当只有一户的时候，我们只能偷取这一家，所以 dp[0] = nums[0]，当由两户的时候，我们只能偷取其中金额最多的一户，所以 dp[1] = max(nums[0], nums[1]); 。
export function rob(nums: number[]): number {
  const memory: number[] = Array.from(nums, (value, key) => { // *建立初始值
    if (key === 0) return value;
    if (key === 1) return Math.max(nums[0], nums[1]);
    return 0;
  });

  for (let i = 2; i < nums.length; i++) {
    memory[i] = Math.max(...memory.slice(0, i - 1)) + nums[i];// *注意：这里截取的是memory，不是nums。
  }
  return Math.max(...memory); // *注意：这里返回的不是最后一个元素，而是memory中最大的哪个元素。因为最后一个元素不一定就是最大的元素，比如 [1,2,3,1] 最大的应该是：1+3 = 4 也就是索引为2.
}
