// *位运算加法 注意对于负数也是成立的
export default function bitAdd(a: number, b: number): number {
  let sum = a;
  let carry;
  while (b !== 0) {
    sum = a ^ b;
    carry = (a & b) << 1;
    a = sum;
    b = carry;
  }
  return sum;
}

console.log(bitAdd(-10, 3));

/**
 * a = 10; b = 3 解析
 * a = 10 = 1010; b = 3 = 0011; 要实现的结果为 1010 + 0011 = 1101 = 13
 * !a ^ b = 1001 加法是最简单的，只需要满足逢 2 进位就可以了， 1 + 1 = 10, 1 + 0 = 1, 0 + 0 = 0; 这样的等式使用 ^ 异或就可以实现。比如这里得出的结果 1001 很明显保留了 a, b 两者相加不会进位的部分，这个时候，我们再把需要进位的部分放进去就可以了。
 * *a & b = 0010, & 与运算，很明显就是将 a, b 中将会进位的部分保留下来，因为需要进位，所以使用了 << 1 向左移位，得到 0100
 * *其实这个时候如果将 1001 ^ 0100 = 1101 = 13 已经可以得出结果了，但是如果表达式为： 1010 ^ 0010 那么又会产生进位，所以是不能一次得到结果的，需要进行循环。什么时候循环结束呢？那么就是当没有进位的时候循环结束，所以当 carry = 0 时循环结束。
 * */